# 如何判断一个对象是垃圾
> 没有任何引用的对象就是垃圾。

## 判断方法
1. 引用计数算法
- 通过判断对象的引用数量，来决定对象是否可以被回收。
- 每个对象实例都有一个引用计数器，如果对象被引用，引用计数器加1，引用完成，则-1.
  - 当一个对象被创建并初始化赋值后，该变量计数设置为1
  - 每当有一个地方引用它时，计数器值就加1
  - 当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1
- 任何引用计算为零的对象实例都可以当做垃圾被回收。

- 优点： 执行效率高，程序执行受影响小。
- 缺点： 无法检测出循环引用的情况，导致内存泄漏，引用计数器增加了程序执行的开销。


2. 可达性分析算法（根搜索算法）
- 通过判断对象的引用链是否可达来决定对象是否可以被回收。
- 垃圾回收器会对整个对象图进行遍历，它从GC root 开始，一直查找其他对象，垃圾回收器会对所有遍历到的对象，标记为存活，GC root 无法到达的对象，就被标记为不可达对象。也就被标记为垃圾。

![标记](https://upload-images.jianshu.io/upload_images/3789193-db98b5d3a266c24d.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 关于标记阶段有几个关键点是值得注意的：
  1. 开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。
  2. 暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。
  3. 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：
    -  如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法（可看作析构函数，类似于OC中的dealloc，Swift中的deinit）。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。
    - 如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。

## 垃圾回收算法
- 标记清除算法
- 复制算法
- 标记整理算法
- 分代收集算法

### 标记清除算法
- 标记： 从根集合进行扫描，对存活的对象进行标记。
- 清除： 对堆内存从头到尾进行线性遍历，回收不可达对象内存。

- 优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。
- 缺点：
  - 标记和清除过程的效率都不高
  - 标记清除后会产生大量不连续的内存碎片

![标记清除算法](https://upload-images.jianshu.io/upload_images/3789193-05ac8d99f632c6c7.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 复制算法
- 复制算法将内存按容量按一定的比例分为对象面和空闲面。
- 对象在对象面上创建。
- 存活的对象被从对象面复制到空闲面。(这个时候空闲面变为对象面)
- 将对象面中所有的对象全部清空。 (这个时候，对象面变为空闲面)。 年轻代很多垃圾收集器，都用这个算法回收。

- 优点：
  - 解决了内存碎片化的问题。
  - 顺序分配内存，简单高效。
  - 适用于对象存活率低的场景。
  - 回收的时候针对整块内存进行回收，运行高效
- 缺点： 
  - 不适合对象存活率高的场景
  - 可一次性分配的最大内存缩小
![复制算法](https://upload-images.jianshu.io/upload_images/3789193-f3564647800ab93c.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)


### 标记整理算法
- 该算法标记的过程与标记清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。
- 优点：
  - 经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。
- 缺点：
  - GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。

![标记整理算法](https://upload-images.jianshu.io/upload_images/3789193-27c645c7700f687b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)



### 分代收集算法
1. 新生代（年轻代）（Young Generation）
- 几乎所有新生成的对象首先都是放在新生代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。
- 大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。
- 回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。
- 当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。
- 当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。
- 若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。

2. 老年代（Old Generation）
- 在新生代代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。
- 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。

1. 持久代（Permanent Generation）
- 用于存放类的元数据, 字符串池, 类的静态变量
- 对永久代的回收主要回收两部分内容：废弃常量和无用的类。


新生代GC（Minor GC）：发生在新生代的垃圾收集动作。因为Java对象大多都具有朝生夕灭的特性，因此Minor GC非常频繁(不一定等Eden区满了才触发)，一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集。

老年代GC（Major GC/Full GC）：发生在老年代的垃圾回收动作。
- Major GC，经常会伴随至少一次Minor GC。
- 由于老年代中的对象生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。
- 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。

![](https://upload-images.jianshu.io/upload_images/3789193-1be27c1633ad2eeb.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

## 触发主GC的条件
1. 当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。
2. Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。
